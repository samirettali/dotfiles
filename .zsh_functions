# Development
jjj() {
	clear
	echo "###############"
	echo "# COMPILATION #"
	echo "###############"
	javac "$1"
	echo "\n###############"
	echo "## EXECUTION ##"
	echo "###############\n"
	time java $(sed 's/.java//' <<< "$1")
	rm *.class
}

ccc() {
	clear
	echo "###############"
	echo "# COMPILATION #"
	echo "###############"
    gcc "$1" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$1")
	echo "\n###############"
	echo "## EXECUTION ##"
	echo "###############\n"
	rm $(sed 's/\.c//' <<< "$1")
}

ccd() {
	gcc "$1" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$1")
}

cca() {
	for f in *.c; do
        gcc "$f" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$f")
	done
}

# Automata graph generation
graph() {
	dot -Tpng -Gsize=192,108\! -Gdpi=10 "$1".gv -o "$1".png && xdg-open "$1".png

}

graphsvg() {
	dot -Tsvg "$1".gv -o "$1".svg && xsvg "$1".svg
}

# Find files
f() {
	find -iname "*$1*" 2>/dev/null
}

# Edit all files containing a string
vack() {
    vim $(ack -l "$1")
}

# Go up n directories
up() {
	cd $(eval printf '../'%.0s {1.."$1"})
}

fixpermissions() {
	find . -type d -exec chmod 755 -- {} +
	find . -type f -exec chmod 644 -- {} +
}

# Create new tmux session with name if passed
t() {
    if [ -z "$1" ]; then
        tmux
    else
        tmux new -A -s "$1"
    fi
}

# Throw away directory
tad() {
	local ts=$(date +%s)
	local d="$HOME/.throw-away/$ts"
	mkdir -p "$d"
	(cd "$d"; zsh -c tmux)
	rm -r "$d"
}

dnd() {
	local name="$(date +%F)"
	mkdir "$name" && cd "$name"
}

# Last downloaded file
ldf() {
	local file=~/Downloads/$(ls -1t ~/Downloads/ | head -n1)
	echo "$file"
	mv "$file" .
}

lt-ascii() {
	sed -e 's/[ÀÁÂÃÄÅ]/A/g'|
	sed -e 's/Æ/AE/g'      |
	sed -e 's/Ç/C/g'       |
	sed -e 's/[ÈÉÊË]/E/g'  |
	sed -e 's/[ÌÍÎÏ]/I/g'  |
	sed -e 's/Ñ/N/g'       |
	sed -e 's/[ÒÓÔÕÖØ]/O/g'|
	sed -e 's/[ÙÚÛÜ]/U/g'  |
	sed -e 's/ Ý /Y/g'     |
	sed -e 's/[àáâãä]/a/g' |
	sed -e 's/æ/ae/g'      |
	sed -e 's/ç/c/g'       |
	sed -e 's/[èéêë]/e/g'  |
	sed -e 's/[ìíîï]/i/g'  |
	sed -e 's/ñ/n/g'       |
	sed -e 's/[òóôöø]/o/g' |
	sed -e 's/[ùúûü]/u/g'  |
	sed -e 's/ ý /y/g'
}

# Better tree visualization
tre() {
	tree -aC -I '.git|node_modules|vendor|.idea|.vscode' --dirsfirst "$@" | less -FRNX
}

# Extract archive
extract() {
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# Add extension to all files in a directory
add_extension() {
	find . -type f -exec mv '{}' '{}'.$1 \;
}

# Search for a string in file and replace it
sifr() {
    find . -type f -name '*.txt' -exec sed -i "s/$1/$2/g" {} \;
}

# See all processes with given name
proc() {
    pgrep "$1" && ps -o uid,pid,ppid,time,command -C "$1"
}

isotoutf() {
    iconv -f ISO-8859-1 -t UTF-8//TRANSLIT "$1" -o "$1".utf8
}

# Compile and clean latex
ptex() {
    pdflatex "$1"
    rm $(sed 's/tex/log/' <<< "$1")
    rm $(sed 's/tex/aux/' <<< "$1")
}

# Go to git repository root
groot() {
    readonly old_pwd="$PWD"
    while [[ 1 ]]; do
        cd ..
        if [[ "$PWD" == "/" ]]; then
            cd "$old_pwd"
            echo "No repository found, returned to $PWD"
            return 1
        fi
        for repo in ".git" ".hg"; do
            if [[ -d "$repo" ]]; then
                echo "Found $repo at $PWD"
                return 0
            fi
        done
    done
}

# Backup file
bak() {
    declare target=$1;
    if [[ "${target:0-1}" = "/" ]]; then
        target=${target%%/}; # Strip trailing / of directories
    fi
    mv -v $target{,.bak}
}

# CTF stuff

longstrings() {
    strings "$1" | awk 'length($0) > 10' | sort -u
}

# Move to Kali vm shared folder
mvk() {
    mv "$@" ~/CTF/Kali
}

# Use ack to find folder and move to it
fd() {
    local dir
    dir=$(find ${1:-.} -path '*/\.*' -prune \
        -o -type d -print 2> /dev/null | fzf +m) &&
    cd "$dir"
}

# Create new vagrant machine
vm() {
    mkdir "$1"
    cd "$1"
    cp ~/Documents/Vagrantfile .
    vim Vagrantfile

    read REPLY\?"Do you want to build the machine? [Y\n] "
    if [[ -z $REPLY || $REPLY =~ ^[Yy]$ ]]; then
        vagrant up && vagrant ssh
    fi
}
