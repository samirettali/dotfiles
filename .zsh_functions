# Development
jjj() {
    clear
    echo "###############"
    echo "# COMPILATION #"
    echo "###############"
    javac "$1"
    echo "\n###############"
    echo "## EXECUTION ##"
    echo "###############\n"
    time java $(sed 's/.java//' <<< "$1")
    rm *.class
}

ccc() {
    clear
    echo "###############"
    echo "# COMPILATION #"
    echo "###############"
    gcc "$1" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$1")
    echo "\n###############"
    echo "## EXECUTION ##"
    echo "###############\n"
    rm $(sed 's/\.c//' <<< "$1")
}

cnasm() {
    nasm -f bin $1 -o $(sed 's/\.asm//' <<< $1).bin && qemu-system-x86_64 $(sed 's/\.asm//' <<< $1).bin
}

ccd() {
    gcc "$1" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$1")
}

cca() {
    for f in *.c; do
        gcc "$f" -g -Wall -rdynamic -o $(sed 's/\.c//' <<< "$f")
    done
}

# Edit all files containing a string
vack() {
    vim $(ack -l "$1")
}

# Go up n directories
up() {
    cd $(eval printf '../'%.0s {1.."$1"})
}

fixpermissions() {
    find . -type d -exec chmod 755 -- {} +
    find . -type f -exec chmod 644 -- {} +
}

# Create new tmux session with name if passed
t() {
    if [ -z "$1" ]; then
        tmux
    else
        tmux new -A -s "$1"
    fi
}

# Throw away directory
tad() {
    local ts=$(date +%s)
    local d="$HOME/.throw-away/$ts"
    mkdir -p "$d"
    (cd "$d"; zsh -c tmux)
    rm -r "$d"
}

# Last downloaded file
ldf() {
    local file=~/Downloads/$(ls -1t ~/Downloads/ | head -n1)
    echo "$file"
    mv "$file" .
}

# Better tree visualization
tre() {
    tree -aC -I '.git|node_modules|vendor|.idea|.vscode' --dirsfirst "$@" | less -FRNX
}

# Extract archive
extract() {
    if [ -f "$1" ] ; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
        local didfolderexist=false
        if [ -d "$foldername" ]; then
            didfolderexist=true
            read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                return
            fi
        fi
        mkdir -p "$foldername" && cd "$foldername"
        case $1 in
            *.tar.bz2) tar xjf "$fullpath" ;;
            *.tar.gz) tar xzf "$fullpath" ;;
            *.tar.xz) tar Jxvf "$fullpath" ;;
            *.tar.Z) tar xzf "$fullpath" ;;
            *.tar) tar xf "$fullpath" ;;
            *.taz) tar xzf "$fullpath" ;;
            *.tb2) tar xjf "$fullpath" ;;
            *.tbz) tar xjf "$fullpath" ;;
            *.tbz2) tar xjf "$fullpath" ;;
            *.tgz) tar xzf "$fullpath" ;;
            *.txz) tar Jxvf "$fullpath" ;;
            *.zip) unzip "$fullpath" ;;
            *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Add extension to all files in a directory
add_extension() {
    find . -type f -exec mv '{}' '{}'.$1 \;
}

# Search for a string in file and replace it
sifr() {
    find . -type f -name '*' -exec sed -i "s/$1/$2/g" {} \;
}

# See all processes with given name
proc() {
    pgrep "$1" && ps -o uid,pid,ppid,time,command -C "$1"
}

isotoutf() {
    iconv -f ISO-8859-1 -t UTF-8//TRANSLIT "$1" -o "$1".utf8
}

# Compile and clean latex
ptex() {
    pdflatex "$1"
    rm $(sed 's/tex/log/' <<< "$1")
    rm $(sed 's/tex/aux/' <<< "$1")
}

# Go to git repository root
groot() {
    readonly old_pwd="$PWD"
    while [[ 1 ]]; do
        cd ..
        if [[ "$PWD" == "/" ]]; then
            cd "$old_pwd"
            echo "No repository found, returned to $PWD"
            return 1
        fi
        for repo in ".git" ".hg"; do
            if [[ -d "$repo" ]]; then
                echo "Found $repo at $PWD"
                return 0
            fi
        done
    done
}

# Go to project root
proot() {
    readonly old_pwd="$PWD"
    while [[ 1 ]]; do
        cd ..
        if [[ "$PWD" == "/" ]]; then
            cd "$old_pwd"
            echo "Project structure not found, returned to $PWD"
            return 1
        fi
        if [[ -f "Makefile" ]]; then
            echo "Found Makefile at $PWD"
            return 0
        fi
    done
}

# Backup file
bak() {
    declare target=$1;
    if [[ "${target:0-1}" = "/" ]]; then
        target=${target%%/}; # Strip trailing / of directories
    fi
    cp -v $target{,.bak}
}

# CTF stuff

# Find strings longer than 10 characters
longstrings() {
    strings "$1" | awk 'length($0) > 10' | sort -u
}

# Move to Kali vm shared folder
mvk() {
    mv "$@" ~/CTF/kali-ctf
}

# Move to Kali vm shared folder
cpk() {
    cp "$@" ~/CTF/kali-ctf
}

# Use ack to find folder and move to it
# fd() {
#     local dir
#     dir=$(find ${1:-.} -path '*/\.*' -prune \
#         -o -type d -print 2> /dev/null | fzf +m) &&
#     cd "$dir"
# }

# Create new vagrant machine
vm() {
    mkdir "$1"
    cd "$1"
    cp ~/Documents/Vagrant/Vagrantfile .
    vim Vagrantfile

    read REPLY\?"Do you want to build the machine? [Y\n] "
    if [[ -z $REPLY || $REPLY =~ ^[Yy]$ ]]; then
        vagrant up && vagrant ssh
    fi
}

# Foreground and background switching
function fg-bg() {
  if [[ $#BUFFER -eq 0 ]]; then
    fg
  else
    zle push-input
  fi
}

# Replace non-ascii characters
lt-ascii() {
    sed -e 's/[ÀÁÂÃÄÅ]/A/g'|
    sed -e 's/Æ/AE/g'      |
    sed -e 's/Ç/C/g'       |
    sed -e 's/[ÈÉÊË]/E/g'  |
    sed -e 's/[ÌÍÎÏ]/I/g'  |
    sed -e 's/Ñ/N/g'       |
    sed -e 's/[ÒÓÔÕÖØ]/O/g'|
    sed -e 's/[ÙÚÛÜ]/U/g'  |
    sed -e 's/ Ý /Y/g'     |
    sed -e 's/[àáâãä]/a/g' |
    sed -e 's/æ/ae/g'      |
    sed -e 's/ç/c/g'       |
    sed -e 's/[èéêë]/e/g'  |
    sed -e 's/[ìíîï]/i/g'  |
    sed -e 's/ñ/n/g'       |
    sed -e 's/[òóôöø]/o/g' |
    sed -e 's/[ùúûü]/u/g'  |
    sed -e 's/ ý /y/g'
}

# Start a simple web server in the current directory
http() {
    local port="${1:-8000}"
    python2.7 -m SimpleHTTPServer $port
}

repos() {
    red='\033[0;31m'
    green='\033[0;32m'
    yellow='\033[0;33m'
    off='\033[0m'

    repositories=("$HOME/Scripts" "$HOME/CTF/kali-ctf" )
    for folder in $(ls -1 $HOME/Projects); do
        repositories+="$HOME/Projects/$folder"
    done

    for repo in ${repositories[@]}; do
        repo_name=$(echo $repo | sed 's|.*/||')
        echo "${green}[*] Checking $repo_name repo${off}"
        CHANGED=$(git -C $repo diff-index --name-only HEAD --)
        UNSTAGED=$(git -C $repo status --porcelain 2>/dev/null| grep "^??" | wc -l)
        if [ -z $CHANGED ] && [ -z $UNSTAGED ]; then
            echo "${green}\t[+] Repo is clean${off}"
        else
            if [ $CHANGED ]; then
                echo "${yellow}  [-] Repo has uncommitted files${off}"
            fi
            if [ $UNSTAGED ]; then
                echo "${red}  [-] Repo has unstaged files${off}"
            fi
        fi
        echo ""
    done
}
